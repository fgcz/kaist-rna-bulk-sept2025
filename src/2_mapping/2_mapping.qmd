---
title: "Part 2: Mapping"
format:
  html:
    embed-resources: true
    toc: true
    toc-location: left
    toc-depth: 3
    title-block-banner: "#00A7FF"
filters:
  - flourish
css: assets/style.css
editor: visual
bibliography: assets/references.bib
---

# Mapping with STAR

For this section, we will be aligning our processed fastqs using STAR [@dobin2012] and looking at the alignments in IGV.

## Exploring test data

First, let's look at our test data for this section: fastp-processed files based on the subsampled data from the previous section to speed up alignment.

Now that the data has been downloaded, let's see exactly what we are dealing with. To this end, run the following cell. It calls [seqkit](https://bioinf.shenwei.me/seqkit/usage/) to output some stats about the fastq files about the cell-line HCT116 samples.

```{bash}
#| class-output: scrolling

echo "Running on raw fastqs..."
seqkit stats --skip-err --quiet ~/work/gse154927-subsampled/fastq/HCT116*fastq.gz
echo -e "\n\n"
echo "Running on trimmed/filtered fastqs..."
seqkit stats --skip-err --quiet ~/work/gse154927-subsampled/fastp/HCT116*fastq.gz
```

### Exercise #1

1.  How many reads does each sample have? How does this compare to the input fastq files? Hint: compare the read counts in the two subdirectories from `~/work/gse154927-subsampled`

2.  Is the minimum length of each read in the fastq files expected?

::: {.callout-tip collapse="true"}
## Solutions

```{r, warning=FALSE}
suppressPackageStartupMessages(library(tidyverse))

dat_raw <- vroom::vroom("~/work/gse154927-subsampled/fastq/dataset.tsv", show_col_types = FALSE) %>% arrange(Name)
dat_fastp <- vroom::vroom("~/work/gse154927-subsampled/fastp/dataset.tsv", show_col_types = FALSE) %>% arrange(Name)

tibble(Name=dat_raw$Name, OriginalCount=dat_raw$"Read Count", FastpCount=dat_fastp$"Read Count", ReadFraction=dat_fastp$"Read Count" / dat_raw$"Read Count")
```

1.  As expected, each sample has around a tenth of the input reads of our initial sequencing data. 500'000 to 1'000'000 may seem like little considering the general recommendation of 20M for bulk RNA-seq, but we would likely still get somewhat usable count data from this assuming we mostly care about large fold changes (biological effect size).
2.  Yes, we specified a minimum length of 30bp when we ran fastp, which is what we see in the seqkit output.
:::

## Running STAR

We are now ready to run the STAR aligner on our inputs. Note that an import step has already been done for us, namely the creation of the STAR index directory. How to generate this directory be found [here](https://hbctraining.github.io/Intro-to-rnaseq-hpc-O2/lessons/03_alignment.html#running-star). Alignment with STAR can (despite its purported speed) take a while and use a lot of RAM (\~30GB for the human genome), so **do not** run the code chuck below.

```{bash, eval=FALSE}
set +e

TRIMMED_FASTQS=~/work/gse154927-subsampled/fastp
OUTPUT_DIR=~/work/results/2_mapping/STAR_alignment
STAR_INDEX=~/work/grch38-p13-gencode-release-42/annotation/genes_STARIndex
GENES_BED=~/work/grch38-p13-gencode-release-42/annotation/genes.bed
mkdir -p $OUTPUT_DIR

ALL_SAMPLES=$(cat ~/work/gse154927-subsampled/fastp/dataset.tsv | awk -F"\t" '{print $1}' | tail +2 | sort)

# Start processing with fastp
for SAMPLE_NAME in $ALL_SAMPLES; do
  echo SAMPLE_NAME
  R1_FILE=$TRIMMED_FASTQS/"${SAMPLE_NAME}_R1.fastq.gz"
  R2_FILE=$TRIMMED_FASTQS/"${SAMPLE_NAME}_R2.fastq.gz"
  
  # First do alignment with STAR using a pre-built index
  echo STAR \
	  --genomeDir $STAR_INDEX \
	  --readFilesIn $R1_FILE $R2_FILE \
	  --twopassMode None \
	  --runThreadN 2 \
	  --sjdbOverhang 150 \
	  --outFilterType BySJout \
	  --outFilterMatchNmin 30 \
	  --outFilterMismatchNmax 10 \
	  --outFilterMismatchNoverLmax 0.05 \
	  --outMultimapperOrder Random \
	  --alignSJDBoverhangMin 1 \
	  --alignSJoverhangMin 8 \
	  --alignIntronMax 100000 \
	  --alignMatesGapMax 100000  \
	  --outFilterMultimapNmax 50 \
	  --chimSegmentMin 15 \
	  --chimJunctionOverhangMin 15 \
	  --chimScoreMin 15 \
	  --chimScoreSeparation 10 \
	  --outSAMstrandField intronMotif \
	  --alignEndsProtrude 10 ConcordantPair \
	  --outSAMmultNmax 4 \
	  --outSAMattributes All  \
	  --outStd BAM_Unsorted \
	  --outSAMtype BAM Unsorted \
    --outSAMattrRGline ID:$SAMPLE_NAME SM:$SAMPLE_NAME \
    --readFilesCommand zcat > $OUTPUT_DIR/$SAMPLE_NAME.out.bam
  
  # Sort and index
  samtools sort --write-index -l 9 -m 2625M -@ 4 $OUTPUT_DIR/$SAMPLE_NAME.out.bam -o $OUTPUT_DIR/$SAMPLE_NAME.bam##idx##$OUTPUT_DIR/$SAMPLE_NAME.bam.bai
  rm -f $OUTPUT_DIR/$SAMPLE_NAME.out.bam
  
  # “Guess” how RNA-seq sequencing were configured
  infer_experiment.py -r $GENES_BED \
    -i $OUTPUT_DIR/$SAMPLE_NAME.bam -s 200000 > $OUTPUT_DIR/$SAMPLE_NAME"_inferred.txt"
done
```

Let's first take a look at the outputs first. The above function ran STAR, sorted the bam output, indexed it, and ran a script to determine the strandedness of the inputs. Let's perform a quick exercise related to the plain text outputs generated by STAR.

Since we did not run this code block, let's copy over the results as if we had run it.

```{bash}
OUTPUT_DIR=~/work/results/2_mapping/STAR_alignment
mkdir -p $OUTPUT_DIR
cp -r ~/work/gse154927-subsampled/bams/* $OUTPUT_DIR
```

### Exercise #2

1.  Take a look at the files ending in "\_Log.final.out". Which sample has the highest percentage of primary alignments? Which has the lowest percentage?
2.  What is the range of splices for the samples? Do you think these are real?
3.  (Challenge) Find the answers to the above two questions programmatically.
4.  We ran a python file called `infer_experiment.py`, which aims to infer the strandedness of bam alignments using a bed file for reference. These outputs were placed into the files ending in "\_inferred.txt". Is the predicted strandedness consistent with our expectations?

::: {.callout-tip collapse="true"}
## Solutions

Let's first answer number 3, as it will help us to answer the other questions. This is obviously not the only way to do this, so feel free to use your own (potentially more efficient) solution.

```{r}
suppressPackageStartupMessages(library(tidyverse))
starLogFiles <- Sys.glob("~/work/results/2_mapping/STAR_alignment/*_STAR.log")
logFiles <- lapply(starLogFiles, function(x) {
  tmp <- data.table::fread(x, sep="|", strip.white=TRUE, nrows=9, skip="Uniquely mapped") %>% 
    as.data.frame()
  tmpVals <- str_trim(tmp[,2])
  tmpNames <- tmp[,1]
  names(tmpVals) <- tmpNames
  return(as_tibble(as.list(tmpVals)))
}) %>% 
  bind_rows() %>%
  mutate("Uniquely mapped reads %"=sub("%", "", `Uniquely mapped reads %`)) %>%
  mutate_all(., as.numeric) %>%
  mutate(Name = basename(starLogFiles))

summary(logFiles$"Number of splices: Total")
summary(logFiles$"Number of splices: Annotated (sjdb)")
```

1.  SW480_EpCAMlow_1 is the sample with the highest mapping rate. HCT116_EpCAMlow_2_STAR is the sample with the lowest mapping rate.
2.  3E4 to 6.4E5. Compare this to the total amount of non-canonical splice sites. The amount of annotated splice sites makes up the vast majority of splice sites.
3.  (see code)
4.  Yes, the output is not stranded.
:::

------------------------------------------------------------------------

# Visualisation of BAM Files in IGV

Now we will visualise the results of the alignment in IGV.

## 1. Download and install IGV on your computer

URL: https://software.broadinstitute.org/software/igv/download

Should include Java as required.

<img src="screenshots/screenshot11.png" width="70%"/>

## 2. Open IGV

Download the correct reference, which in our case, is **Human (hg38)**. If you can't see it on the list, click "More".

<img src="screenshots/screenshot12.png" width="50%"/>

## 3. Load the BAM files into IGV

A set of alignments have been prepared for you, corresponding to 2 samples from our cancer bulk RNA dataset.

[**Important**]{style="color: red;"}: You do not need to download these files. Simply copy the links and paste them into IGV as shown below.

HCT116_EpCAMhigh_1:

-   https://fgcz-gstore.uzh.ch/public/KAIST_SS25/GSE154927_full/bams/HCT116_EpCAMhigh_1.bam

-   https://fgcz-gstore.uzh.ch/public/KAIST_SS25/GSE154927_full/bams/HCT116_EpCAMhigh_1.bam.bai

HCT116_EpCAMlow_1

-   https://fgcz-gstore.uzh.ch/public/KAIST_SS25/GSE154927_full/bams/HCT116_EpCAMlow_1.bam

-   https://fgcz-gstore.uzh.ch/public/KAIST_SS25/GSE154927_full/bams/HCT116_EpCAMlow_1.bam.bai

#### Loading the files

<img src="screenshots/screenshot15.png" width="70%"/>

<img src="screenshots/screenshot16.png" width="70%"/>

### Questions

Search for the gene `ESRP1` and take a look at the reads mapped to this gene.

-   **Question 1**: What is the gene model? Do our reads map to the right part of the gene? (Hint: Take a look at the annotation track at the bottom)

-   **Question 2**: Is the gene expressed in samples from both conditions?

-   **Question 3**: Is there a difference in the read coverage between samples from both conditions? (Hint: Take a look at the number of reads in the coverage track)

Next, right click on the sample track, select `Sashimi Plot`, and then `OK` to include both samples.

<img src="screenshots/screenshot17.png" width="50%"/>

-   **Question 4**: How many isoforms are identified?

-   **Question 5**: Look at the splice junctions, which isoforms are present almost exclusively in one sample? Which sample?
