---
title: "Part 2: Mapping"
format:
  html:
    embed-resources: true
    toc: true
    toc-location: left
    toc-depth: 3
    title-block-banner: "#00A7FF"
css: style.css
editor: visual
bibliography: references.bib
---

# Mapping with STAR

For this section, we will be aligning our processed fastqs using STAR [@dobin2012].

## Downloading test data

First, let's download our dataset for this section. If you haven't already, please delete all fastp generated data from the previous section. Don't worry, we will download it at a later point again from the FGCZ server. Then, let's download our test data for this section: fastp-processed files which have been downsampled by 10X to speed up alignment.

```{bash}
CURR_DIR=$(pwd)
cd ../..

# Download the data
FASTP_OUTDIR=results/1_qc/fastp_downsampled
mkdir -p $FASTP_OUTDIR
cd $FASTP_OUTDIR
echo "Depositing data in "$FASTP_OUTDIR
curl -O https://fgcz-gstore.uzh.ch/public/RNASeqCourse/yeast_fastp_downsampled_for_STAR.tar

# Extract data
tar -xvf yeast_fastp_downsampled_for_STAR.tar
rm -f yeast_fastp_downsampled_for_STAR.tar

# back home
cd $CURR_DIR
```

Now that the data has been downloaded, let's see exactly what we are dealing with. To this end, run the following cell. It calls [seqkit](https://bioinf.shenwei.me/seqkit/usage/) to output some stats about the fastq files.

```{bash}
/opt/seqkit stats ../../results/1_qc/fastp_downsampled/*fastq.gz
```

### Exercise #1

1.  How many reads does each sample have? How does this compare to the input fastq files?

2.  Is the minimum length of each read in the fastq files expected?

::: {.callout-tip collapse="true"}
## Solutions

1.  As expected, each sample has around a tenth of the input reads of our initial sequencing data. 500'000 to 1'000'000 may seem like little considering the general recommendation of 20M for bulk RNA-seq, but it is enough to actually get reasonable results for yeast.
2.  Yes, we specified a minimum length of 30bp when we ran fastp, which is what we see in the seqkit output.
:::

## Running STAR

We are now ready to run the STAR aligner on our inputs. Note that an import step has already been done for us, namely the creation of the STAR index directory. How to generate this directory be found [here](https://hbctraining.github.io/Intro-to-rnaseq-hpc-O2/lessons/03_alignment.html#running-star). Alignment with STAR can (despite its purported speed) take a while, around \~15 minutes for all samples, so look over commands in the meantime.

```{bash}
CURR_DIR=$(pwd)
cd ../..

TRIMMED_FASTQS=results/1_qc/fastp_downsampled
OUTPUT_DIR=results/2_mapping/STAR_alignment
mkdir -p $OUTPUT_DIR

# Start processing with fastp
for FASTQ in $TRIMMED_FASTQS/*_trimmed_R1.fastq.gz
  do SAMPLE_NAME=$(basename ${FASTQ%_trimmed_R1.fastq.gz})
  echo $FASTQ
  
  # First do alignment with STAR using a pre-built index
  time /opt/STAR \
    --genomeDir data/supplementary-files/Ensembl_R64_genes_STARIndex \
    --outFileNamePrefix $OUTPUT_DIR/$SAMPLE_NAME"_" \
    --readFilesIn $FASTQ --twopassMode None --runThreadN 4 \
    --sjdbOverhang 150 --outFilterType BySJout --outFilterMatchNmin 30 \
    --outFilterMismatchNmax 10 --outFilterMismatchNoverLmax 0.05 \
    --outMultimapperOrder Random --alignSJDBoverhangMin 1 \
    --alignSJoverhangMin 8 --alignIntronMax 1000 --alignMatesGapMax 1000 \
    --outFilterMultimapNmax 50 --chimSegmentMin 15 \
    --chimJunctionOverhangMin 15 --chimScoreMin 15 --chimScoreSeparation 10 \
    --outSAMstrandField intronMotif --alignEndsProtrude 3 ConcordantPair \
    --outSAMattributes All --outStd BAM_Unsorted --outSAMtype BAM Unsorted \
    --outSAMattrRGline ID:$SAMPLE_NAME SM:$SAMPLE_NAME \
    --readFilesCommand zcat > $OUTPUT_DIR/$SAMPLE_NAME.out.bam
  
  # Sort and index
  samtools sort -l 9 -m 2625M -@ 4 $OUTPUT_DIR/$SAMPLE_NAME.out.bam -o $OUTPUT_DIR/$SAMPLE_NAME.bam
  rm -f $OUTPUT_DIR/$SAMPLE_NAME.out.bam
  samtools index $OUTPUT_DIR/$SAMPLE_NAME.bam
  
  # “Guess” how RNA-seq sequencing were configured
  infer_experiment.py -r data/supplementary-files/Ensembl_R64_genes/genes.bed \
    -i $OUTPUT_DIR/$SAMPLE_NAME.bam -s 200000 > $OUTPUT_DIR/$SAMPLE_NAME"_inferred.txt"
done

rm -rf $TRIMMED_FASTQS

# Back home
cd $CURR_DIR
```

Let's first take a look at the outputs first. The above function ran STAR, sorted the bam output, indexed it, and ran a function to determine the strandedness of the inputs. Let's perform a quick exercise related to the plain text outputs generated by STAR.

### Exercise #2

1.  Take a look at the files ending in "\_Log.final.out". Which sample has the highest percentage of primary alignments? Which has the lowest percentage?
2.  What is the range of splices for the samples? Do you think these are real?
3.  (Challenge) Find the answers to the above two questions programmatically.
4.  We ran a python file called `infer_experiment.py`, which aims to infer the strandedness of bam alignments using a bed file for reference. These outputs were placed into the files ending in "\_inferred.txt". Is the predicted strandedness consistent with our expectations?

::: {.callout-tip collapse="true"}
## Solutions

Let's first answer number 3, as it will help us to answer the other questions. This is obviously not the only way to do this, so feel free to use your own (potenitally more efficient) solution.

```{r}
library(tidyverse)
starLogFiles <- Sys.glob("../../results/2_mapping/STAR_alignment/*_Log.final.out")
logFiles <- lapply(starLogFiles, function(x) {
  tmp <- data.table::fread(x, sep="|", strip.white=TRUE, nrows=9, skip=8) %>% 
    as.data.frame()
  tmpVals <- str_trim(tmp[,2])
  tmpNames <- tmp[,1]
  names(tmpVals) <- tmpNames
  return(as_tibble(as.list(tmpVals)))
}) %>% 
  bind_rows() %>%
  mutate(`Uniquely mapped reads %`=sub("%", "", `Uniquely mapped reads %`)) %>%
  mutate_all(., as.numeric)
logFiles$Names <- basename(starLogFiles)
summary(logFiles) # Solution to exercise 3
```

1.  G2 is the sample with the highest mapping rate. GE3 is the sample with the lowest mapping rate.
2.  1'702 to 6'585. Only a fraction of these splice sites are expected to be real considering the low frequency of splicing in yeast.
3.  (see code)
4.  Yes, the output is largely antisense.
:::

## Alignment QC

We have already performed a few QC steps in the above section. Let's now explore these outputs a bit further using the python-package [RSeQC](https://rseqc.sourceforge.net/). This package contains a number of useful standalone python scripts for running general QC of alignment data, with an emphasis on RNAseq data. In fact, we already used one of these scripts above to infer the strandedness of the experiment.

Only a handful of samples will be run for each program at a time to cut-down on processing time.

### TIN Score

First, let's calculate the TIN for a few samples. This score, short for *transcript integrity number*, is analogous to RIN and measures RNA integrity at the transcript level, rather than at the sample level. Each transcript gets an associated TIN score \$0 \leq TIN \leq 100\$. We can however also summarise these TIN scores across a sample by taking the median to get a sample-level quality measure.

```{bash}
PROJ_DIR=../../
OUTPUT_DIR=$PROJ_DIR/results/2_mapping/rseqc_analysis
BAM_DIR=$PROJ_DIR/results/2_mapping/STAR_alignment
mkdir -p $OUTPUT_DIR

for BAM_FILE in $BAM_DIR/GE2.bam $BAM_DIR/GE4.bam; do
  SAMPLE_NAME=$(basename ${BAM_FILE%.bam})
  echo $SAMPLE_NAME
  
  tin.py -r $PROJ_DIR/data/supplementary-files/Ensembl_R64_genes/genes.bed \
    -i $BAM_FILE 2> $OUTPUT_DIR/$SAMPLE_NAME".tin.err"
  mv ./$SAMPLE_NAME".tin.xls" $OUTPUT_DIR
  mv ./$SAMPLE_NAME".summary.txt" $OUTPUT_DIR/$SAMPLE_NAME".tin.summary.txt"
done
```

Take a look at the files ending in ".tin.summary.txt" in the output directory for the medTIN scores.

### Gene Body Plots

This function generates gene-body plots given the bam file and the annotation in bed format.

```{bash}
PROJ_DIR=../../
OUTPUT_DIR=$PROJ_DIR/results/2_mapping/rseqc_analysis
BAM_DIR=$PROJ_DIR/results/2_mapping/STAR_alignment
mkdir -p $OUTPUT_DIR

geneBody_coverage.py -r $PROJ_DIR/data/supplementary-files/Ensembl_R64_genes/genes.bed \
  -i $BAM_DIR/G1.bam,$BAM_DIR/GE2.bam,$BAM_DIR/GE4.bam \
  -o $OUTPUT_DIR/example 2> $OUTPUT_DIR/example.geneBody.err
```

Take a look at the output pdfs. Note the heatmaps are organised from sample with lowest skew at the top to sample with the highest skew at the bottom.

### Read Duplication

This script attempts to quantify the level of duplication present in the bam file. There are more sophisticated [visualisations](https://bioconductor.org/packages/release/bioc/vignettes/dupRadar/inst/doc/dupRadar.html) and [quantifications](https://gatk.broadinstitute.org/hc/en-us/articles/360037052812-MarkDuplicates-Picard-) for determining duplication rate in sequence alignment, but this is a simple alternative. It quantifies duplicates using two methods: 1) reads with the same sequence 2) reads with the same starting position in genome and the same splicing.

```{bash}
PROJ_DIR=../../
OUTPUT_DIR=$PROJ_DIR/results/2_mapping/rseqc_analysis
BAM_DIR=$PROJ_DIR/results/2_mapping/STAR_alignment
mkdir -p $OUTPUT_DIR

for BAM_FILE in $BAM_DIR/GE2.bam $BAM_DIR/GE4.bam; do
  SAMPLE_NAME=$(basename ${BAM_FILE%.bam})
  echo $SAMPLE_NAME
  
  read_duplication.py \
    -i $BAM_FILE -o $OUTPUT_DIR/$SAMPLE_NAME 2> $OUTPUT_DIR/$SAMPLE_NAME".dup.err"
done
```

If the sequencing quality is low, we would expect the number of duplicates quantified by the first method to lower than the second and vice versa.

### GC Content

This script calculates the GC content based on the reads. If the GC content deviates too much than the usual distribution for this species, then it might be indicative that certain genes are over-represented.

```{bash}
PROJ_DIR=../../
OUTPUT_DIR=$PROJ_DIR/results/2_mapping/rseqc_analysis
BAM_DIR=$PROJ_DIR/results/2_mapping/STAR_alignment
mkdir -p $OUTPUT_DIR

for BAM_FILE in $BAM_DIR/GE2.bam $BAM_DIR/GE4.bam; do
  SAMPLE_NAME=$(basename ${BAM_FILE%.bam})
  echo $SAMPLE_NAME
  
  read_GC.py \
    -i $BAM_FILE -o $OUTPUT_DIR/$SAMPLE_NAME 2> $OUTPUT_DIR/$SAMPLE_NAME".GC.err"
done
```

### Bam Stats

This script generates some summary stats in line with the "\_Log.final.out" output files we have looked at before. Compare some of the numbers to ensure they are the same.

```{bash}
PROJ_DIR=../../
OUTPUT_DIR=$PROJ_DIR/results/2_mapping/rseqc_analysis
BAM_DIR=$PROJ_DIR/results/2_mapping/STAR_alignment
mkdir -p $OUTPUT_DIR

for BAM_FILE in $BAM_DIR/GE2.bam $BAM_DIR/GE4.bam; do
  SAMPLE_NAME=$(basename ${BAM_FILE%.bam})
  echo $SAMPLE_NAME
  
  bam_stat.py \
    -i $BAM_FILE > $OUTPUT_DIR/$SAMPLE_NAME".stat.txt"
done
```

Beware the standard output here is piped to a file and this script does not generate any outputs by itself.

### Exercise #3

1.  Which of the above methods is expected to look different had used the full data rather than these sub-sampled fastqs? Assume the subsampling of reads from the original trimmed fastqs was random.
2.  Looking at just these outputs, does it look like we were able to remove issues related to sample GE4?

::: {.callout-note collapse="true" appearance="simple"}
## Solutions

1.  We only expect the read duplication plot to significantly change, since we are less likely to have reads which overlap completely either in sequence or alignment the less reads are present in the sample.
2.  Going off just these QC outputs, it appears as though trimming has largely removed problematic sequences from the sample. Otherwise, the percentage of uniquely aligning sequences would have presumably been lower, we'd have a higher mismatch rate, etc.
:::
