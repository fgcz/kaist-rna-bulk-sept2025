---
title: "Part 4: Differential Expression and Pathway Enrichment"
format:
  html:
    embed-resources: true
    toc: true
    toc-location: left
    toc-depth: 3
    title-block-banner: "#00A7FF"
css: style.css
editor: visual
bibliography: references.bib
---


# Differential Expression Analysis

In this section, we will use the count data from Kallisto from the previous part, redo some of the QC, and perform the differential expression analysis using DESeq2[@DESeq2]. This part is adapted from the official DESeq2 [vignette](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html), available on Bioconductor, so feel free to look there for additional information.

## Preparing data


```{r}
suppressPackageStartupMessages({
  library(SummarizedExperiment)
  library(pheatmap)
  library(RColorBrewer)
  library(stringr)
  library(plotly)
  library(tidyverse)
  library(tximport)
  library(DESeq2)
})
source("../helpers.R")
```


Let's download data. These counts should be mostly identical to the results we produced ourselves in the last step but are provided here as a download for convenience.


```{bash}
CURR_DIR=$(pwd)
cd ../..

# Download the data
KALLISTO_OUTDIR=results/3_quant/kallisto
mkdir -p $KALLISTO_OUTDIR

# change to kallisto dir and delete contents if there are any
cd $KALLISTO_OUTDIR
rm -f ./*

# Download data
echo "Depositing data in "$KALLISTO_OUTDIR
curl -O https://fgcz-gstore.uzh.ch/public/RNASeqCourse/processed_yeast_kallisto_counts.tar

# Extract data
tar -xvf processed_yeast_kallisto_counts.tar
rm -f processed_yeast_kallisto_counts.tar

# Back home
cd $CURR_DIR
```


First, let's create our meta-information frame and instantiate some variables we will use later.


```{r}
# Define meta dataframe for later use
meta <- data.frame(
  Condition=as.factor(rep(c("Glucose", "GlycEth"), each=4)),
  row.names=c(paste0("G", 1:4), paste0("GE", 1:4))
)
conditionColours <- scales::hue_pal()(length(unique(meta$Condition)))
names(conditionColours) <- unique(meta$Condition)
sampleColours <- conditionColours[meta$Condition]
```


::: callout-note
### On `Condition` factor levels

R will choose a reference level for factors based on alphabetical order. Then, once we do the differential expression with DESeq2, you will never tell the DESeq2 functions which level you want to compare against (e.g. which level represents the control group), the comparisons will be based on the alphabetical order of the levels. There are two solutions: you can either explicitly tell results which comparison to make using the contrast argument (this will be shown later), or you can explicitly set the factors levels. In order to see the change of reference levels reflected in the results names, you need to either run `DESeq` or `nbinomWaldTest`/`nbinomLRT` after the re-leveling operation.

In our case, we are lucky in that the Glucose group comes before GlycEth alphabetically and is therefore already set as the reference, and subsequently is the first term when you run `levels(meta$Condition)`. Try it out for yourself.
:::

Again, load the by-transcript gtf file to aid us in the annotation of our Kallisto results.


```{r}
# Load the annotation
seqAnno <- getFeatureAnnotation("../../data/supplementary-files/Ensembl_R64_genes/genes_annotation_byTranscript.txt", dataFeatureType="transcript")
seqAnno <- seqAnno[seqAnno$type %in% "protein_coding", ]
```


Next, we load the counts using `tximport` , a convenience function for loading in count data from a variety of sources (Salmon, Kallisto, featureCounts, etc.) which also performs the aggregation of transcript counts to the gene level (remember that Kallisto produced count files on the transcript level).


```{r}
# Get the files
kallistoFiles <- file.path("../../results/3_quant/kallisto", paste0(rownames(meta), ".txt"))
names(kallistoFiles) <- rownames(meta)
stopifnot(all(file.exists(kallistoFiles)))  # Ensure we have all the files
kallistoFiles

# Use tximport to load the counts
txiKallisto <- tximport(kallistoFiles, type = "kallisto", tx2gene = seqAnno, ignoreAfterBar = TRUE, txIdCol = "transcript_id", geneIdCol = "gene_id")
```


Take a quick look at the `txiKallisto` object we generated and take a look at the rownames. Contrast this to the rownames in the raw files.


```{r}
# Your code here
```


::: {.callout-note appearance="simple"}
`txiKallisto` is a simple list with matrices, `"abundance"`, `"counts"`, and `"length"`, where the transcript level information is summarized to the gene-level. Typically, abundance is provided by the quantification tools as TPM (transcripts-per-million), while the counts are estimated counts (possibly fractional), and the `"length"` matrix contains the effective gene lengths.
:::

Finally, let's construct a *DESeqDataSet* from the `txi` object and sample information in `meta`


```{r}
dds <- DESeq2::DESeqDataSetFromTximport(txiKallisto,
                                        colData=meta,
                                        design=~Condition)
dds
```


## Kallisto QC

Let's first perform a QC step for these counts, to ensure they match up with the feature counts we attained in the last exercise.


```{r}
sigThresh <- 10
isPresent <- counts(dds) > sigThresh
isPresentCond <- rowsum(t(isPresent * 1), group=meta$Condition)
isPresentCond <- t(sweep(isPresentCond, 1,
                         table(meta$Condition)[rownames(isPresentCond)], FUN="/")) >= 0.5
isValid <- rowMeans(isPresentCond) >= 0.5
vsdQC <- DESeq2::vst(dds[isValid,])

# Extract normalized counts
vsdSE <- SummarizedExperiment::assay(vsdQC)
```


### PCA


```{r}
# Run PCA
pcDat  <- prcomp(t(vsdSE), scale. = FALSE)

# Calculate explained variance
varExp <- (100*pcDat$sdev^2)/sum(pcDat$sdev^2)

# Store the explained variance of top 8 PCs
varExp_df <- data.frame(PC= paste0("PC",1:8),
                          varExp=varExp[1:8])

# Scree plot
varExp_df %>%
  ggplot(aes(x=PC,y=varExp, group=1)) +
  geom_point(colour="steelblue", size=4) +
  geom_col(fill="steelblue") +
  geom_line() + 
  theme_bw() + ylim(c(0,100))
```

```{r}
plotPCA(vsdQC, intgroup=c("Condition"), ntop=nrow(vsdQC))
```


### MDS


```{r}
mds <- limma::plotMDS(vsdSE, plot=FALSE)
mdsOut <- mds$eigen.vectors[,1:3]
colnames(mdsOut) <- c("Leading logFC dim1", "Leading logFC dim2", 
                      "Leading logFC dim3")
toPlot <- cbind(meta %>% rownames_to_column("Sample"), mdsOut)
plot_ly(toPlot, x=~`Leading logFC dim1`, y=~`Leading logFC dim2`, z=~`Leading logFC dim3`, color=~Condition, colors="Set1", type='scatter3d', mode='markers+text', text=~Sample, textposition = "top right") %>%
  plotly::layout(title="Classical MDS", scene=list(xaxis=list(title = 'Leading logFC dim1'), yaxis = list(title = 'Leading logFC dim2'), zaxis = list(title = 'Leading logFC dim3')))
```


### Hierarchical Clustering Plot


```{r}
d <- as.dist(1-cor(vsdSE, use="complete.obs"))
hc <- hclust(d, method="ward.D2")
WGCNA::plotDendroAndColors(hc, sampleColours, autoColorHeight=TRUE, hang = -0.1)
```


### Exercise #1

1.  Take a look back at the rendered html from the previous exercise. Do the results look similar?

2.  Plot the top 2'000 most variable genes in a heatmap.


    ```{r}
    # Your code here
    ```


::: {.callout-tip collapse="true" appearance="simple"}
## Solutions

1.  Yes, beyond some minor differences, the results look similar.

2.  The easy solution is to simply copy the code from the previous exercise here:


    ```{r, eval=FALSE}
    # First, we center the matrix
    normCountsCentered <- sweep(normCounts, 1, rowMeans(normCounts))
    # Identify high variance features
    topGenes <- rownames(normCounts)[head(order(rowSds(normCounts, na.rm=TRUE),
                                                decreasing = TRUE), 2000)]

    countsToPlot <- normCountsCentered[topGenes,]

    # Clustering of high variance features
    hmObj <- pheatmap(countsToPlot, 
             clustering_method="ward.D2",
             scale = "row", cluster_rows = TRUE,
             cluster_cols = TRUE, show_rownames = FALSE,
             cutree_rows = 6, cutree_cols = 2,
             treeheight_row = 50, treeheight_col = 50,
             annotation_col = meta,
             fontsize_row = 8, fontsize_col = 9,
             annotation_legend = TRUE,
             fontsize=8)
    hmObj
    ```

:::

## Performing the DE

The standard differential expression analysis steps are wrapped into a single function, `DESeq`. The estimation steps performed by this function are described below, in the manual page for `?DESeq` .


```{r}
# Calculate size factors
dds <- estimateSizeFactors(dds, controlGenes = isValid)
sf <- 1 / dds@colData$sizeFactor

# Calculate DESeq
dds <- DESeq(dds)
res <- results(dds)
res

# Correct NA p-values

```


::: {.callout-note appearance="simple"}
You may wonder why we designated all genes above threshold as being "control genes" when calculating the size factors. Though this list of course also includes genes which will presumably be differentially expressed between the two conditions, the majority of genes will not be, and this therefore serves as a good approximation of the control genes in cases where we do not have this information a priori.
:::

::: {.callout-note appearance="simple"}
Results tables are generated using the function `results`, which extracts a results table with log2 fold changes, p-values and adjusted p-values. With no additional arguments to results, the log2 fold change and Wald test p-value will be for the last variable in the design formula, and if this is a factor, the comparison will be the last level of this variable over the reference level (see previous note on factor levels).
:::

Next, let's take a closer look at the results.

### Exercise #2

1.  What are the columns of the object?
2.  What was the method used for p-value correction?
3.  How many significantly-expressed genes are there assuming we consider genes differentially expressed if `p <= 0.01` and `log2FoldChange >= 0.5` ?

::: {.callout-tip collapse="true" appearance="simple"}
## Solutions

1.  The columns most interesting to us are pvalue, padj (adjusted p-value), and log2FoldChange. Some other columns include `lfcSE`, which gives the standard error of the `log2FoldChange` and `stat`, which gives the Wald statistic. See ?results for more information.

2.  BH (Benjamin-Hochberg)

3.  Execute the following:


    ```{r}
    sum(abs(res$log2FoldChange) >= 0.5 & res$pvalue <= 0.01)
    ```

:::

## Exploring and Visualizing Results

Let's first summarise the results table we get.


```{r}
summary(res)
```


You will notice that there are no low-count genes in the result since we filtered them all out prior to performing the DE.

The `results` function contains a number of arguments to customize the results table which is generated. You can read about these arguments by looking up `?results`. Note that the results function automatically performs independent filtering based on the mean of normalized counts for each gene, optimizing the number of genes which will have an adjusted p-value below a given FDR cutoff, `alpha`. All genes which do not pass the threshold are set to `NA`.


```{r}
res05 <- results(dds, alpha=0.05)
summary(res05)
```


DESeq2 includes a number of convenience methods for visualizing results. The function *plotMA* shows the log2 fold changes attributable to a given variable over the mean of normalized counts for all the samples in the *DESeqDataSet*. Points will be colored red if the adjusted *p* value is less than 0.1 (the default `alpha` value).


```{r}
plotMA(res, ylim=c(-2,2))
```


It is more useful visualize the MA-plot for the shrunken log2 fold changes, which remove the noise associated with log2 fold changes from low count genes without requiring arbitrary filtering thresholds.


```{r}
resultsName <- resultsNames(dds)[-1]
resultsName  # Get the contrast
resLFC <- lfcShrink(dds, coef=resultsName, type="normal")
plotMA(resLFC, ylim=c(-2,2))
```


### Volcano Plot

Let's next visualise the data in a volcano plot. This type of plot summarises the the p-values against log-fold changes as a scatterplot, resulting in a figure resembling a volcano. We will use the packaged `EnhancedVolcano` [@EnhancedVolcano] since it works well out of the box.


```{r, fig.height=5, fig.width=4}
EnhancedVolcano::EnhancedVolcano(resLFC,
                                 lab=rownames(res),
                                 x = 'log2FoldChange', y = 'pvalue')
```


Take a look at the output. Each spot in the scatter plot represents a gene with its corresponding position on the plot determined by the p-value and log-fold change. It additionally plots threshold lines and colors the genes based on which areas of the volcano plot the genes fall. Everything in the red areas passes both the log-fold and p-value thresholds. It additionally plots the names of some of the top genes.

However, due to the large effect size for some genes, it becomes difficult to see genes closer to the threshold lines. In addition, we would ultimately like to see gene names instead of gene IDs. To this end, let's set a maximum x- and y-axis value for our plot and swap the gene IDs out for the gene names.


```{r, fig.height=8, fig.width=6}
ymax <- 100
xmax <- 4
seqAnnoMinimal <- seqAnno %>%
  select(gene_id, gene_name, transcript_id)
rownames(seqAnnoMinimal) <- seqAnnoMinimal$gene_id
seqAnnoMinimal <- seqAnnoMinimal[rownames(resLFC),]

# Set up the object to plot
toPlot <- res %>%
  as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  mutate(pvalue=pmax(pvalue, 1/(10^ymax)),
         log2FoldChange=ifelse(log2FoldChange < 0,
                               pmax(log2FoldChange, -xmax),
                               pmin(log2FoldChange, xmax))) %>%
  merge.data.frame(., seqAnnoMinimal, by='gene_id', all = TRUE)

# Plot the EnhancedVolcano
EnhancedVolcano::EnhancedVolcano(toPlot,
  lab = toPlot$gene_name,
  selectLab = c("SEC72", "MRPL23", "ARG7", "ADY2", "CDC40", "CTI6", "SNF8", "SPA2"),
  drawConnectors = TRUE,
  arrowheads = FALSE,
  xlim = c(-xmax, xmax),
  ylim = c(0, ymax),
  boxedLabels = TRUE,
  parseLabels = TRUE,
  x = 'log2FoldChange',
  y = 'pvalue')
```


### Exercise #3

1.  In this particular experiment, we are interested to see how feeding yeast a diet of glucose versus a diet of glucose and ethanol affects the cells. To this end, the yeast-biologist who performed this experiment was able to provide us with a number of genes involved in glucose transport which they expect to be down-regulated in the Glucose+Ethanol condition relative to the glucose condition. The genes in question are HXT1, HXT4, and HXT11. Modify the above code so that it displays these genes. Was the biologist correct in their assumptions? Would these results be affected much by changing thresholds?

::: {.callout-tip collapse="true" appearance="simple"}
## Solutions

1.  Put the gene names in question to the "selectLab" argument and re-run that line.


    ```{r, fig.height=5}
    EnhancedVolcano::EnhancedVolcano(toPlot,
      lab = toPlot$gene_name,
      selectLab = c("HXT1", "HXT4", "HXT11"),
      drawConnectors = TRUE,
      arrowheads = FALSE,
      xlim = c(-xmax, xmax),
      ylim = c(0, ymax),
      boxedLabels = TRUE,
      parseLabels = TRUE,
      x = 'log2FoldChange',
      y = 'pvalue') + coord_flip()
    ```


    Two of the three genes are extremely down-regulated in the Glucose+Ethanol condition relative to Glucose. We don't expect changing the thresholds to have much affect on this.
:::

